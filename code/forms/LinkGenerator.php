<?php

class CheckfrontLinkGeneratorForm extends CheckfrontForm {
    const FormName = 'CheckfrontLinkGeneratorForm';
    const PackageIDFieldName = 'PackageID';
    const StartDateFieldName = 'StartDate';
    const EndDateFieldName = 'EndDate';
    const AccessKeyFieldName = 'AccessKey';
    const TypeFieldName = 'Type';

    private static $allowed_actions = array(
        'generate' =>  true
    );

    private static $date_field_config = array(
        'showcalendar' => true,
        'datevalueformat' => 'YYYY-MM-DD',
        'min' => CheckfrontModule::DefaultStartDate,
        'max' => CheckfrontModule::DefaultEndDate,
    );

    public function __construct($controller, $name, $fields, $actions, $validator = null) {
        $request = $controller->getRequest();

        $fields = $fields ?: new FieldList();
        $actions = $actions ?: new FieldList();

        $startDate = $this->makeDate($request, self::StartDateFieldName, 'min');
        $endDate = $this->makeDate($request, self::EndDateFieldName, 'max');

        $endpoints = CheckfrontModule::endpoints();

        $types = array(
            $endpoints['public'] => 'public',
            $endpoints['private'] => 'private'
        );

        $fields->merge(
            new FieldList(array(
                $this->makePackageSelectorField($request),
                $this->makeDateField($request, self::StartDateFieldName, $startDate),
                $this->makeDateField($request, self::EndDateFieldName, $endDate),
                new DropdownField(
                    self::TypeFieldName,
                    _t(__CLASS__ . '.TypeFieldLabel'),
                    $types
                ),
//                $this->makeAccessKeyField(self::AccessKeyFieldName, CheckfrontModule::make_access_key())
            ))
        );
        $actions->merge(
            new FieldList(array(
                new FormAction('generate', _t(__CLASS__ . '.GenerateButtonText'))
            ))
        );
        // all fields are mandatory
        $validator = new RequiredFields(
            array_keys($fields->toArray())
        );

        parent::__construct(
            $controller,
            $name,
            $fields,
            $actions,
            $validator
        );
    }

    /**
     * Package/links can be private or public
     * @return array
     */
    public static function access_types() {
        return static::config()->get('access_types');
    }

    /**
     * Logic is in the controller so call there with the incoming requesst.
     * @return mixed
     */
    public function generate() {
        return $this->controller->generate($this->controller->getRequest());
    }

    /**
     * Returns a read-only field for the AccessKeyFieldName initialised to
     *
     * @param $name
     * @param $initValue - this should be a key generated by CheckfrontModule::generate_access_key()
     *
     * @return TextField
     */
    protected function makeAccessKeyField($name, $initValue) {
        $field = new HiddenField(
            self::AccessKeyFieldName,
            _t(__CLASS__ . '.AccessKeyFieldLabel'),
            $initValue
        );
        $field->setReadonly(true);
        return $field;
    }
    /**
     * @param SS_HTTPRequest $request
     * @param null $initValue
     * @return DropdownField
     */
    protected function makePackageSelectorField(SS_HTTPRequest $request, $initValue = null) {
        $name = self::PackageIDFieldName;

        $options = array();

        $startDate = $this->makeDate($request, self::StartDateFieldName, 'min');
        $endDate = $this->makeDate($request, self::EndDateFieldName, 'max');

        // list skus available via the API or get empty array if fails
        $packages = CheckfrontModule::api()->listPackages(
            $startDate,
            $endDate
        )->getPackages();

        foreach ($packages ?: array() as $package) {
            $options[$package->ItemID] = $package->Title;
        }

        $field = new DropdownField(
            $name,
            _t(__CLASS__ . ".{$name}FieldLabel"),
            $options,
            $initValue ?: $request->postVar(self::PackageIDFieldName)
        );
        $field->setEmptyString(_t('CheckfrontLinkGeneratorForm.PackageIDFieldEmptyString', 'Select a package'));

        return $field;
    }

    /**
     * @param SS_HTTPRequest $request
     * @param $name
     * @return DateField
     */
    protected function makeDateField(SS_HTTPRequest $request, $name) {
        $dateField = new DateField(
            $name,
            _t(__CLASS__ . ".{$name}FieldLabel"),
            $request->postVar($name)
        );
        // set the min and max dates to calculated dates not 'relative' dates
        $config = array_merge(
            $this->config()->get('date_field_config'),
            array(
                'min' => $this->makeDate($request, self::StartDateFieldName, 'min'),
                'max' => $this->makeDate($request, self::EndDateFieldName, 'max'),
            )
        );

        foreach ($config as $option => $value) {
            $dateField->setConfig($option, $value);
        }
        return $dateField;
    }


    /**
     * @param SS_HTTPRequest $request
     * @param $fieldName
     * @param $configKey
     * @return bool|string
     */
    protected function makeDate(SS_HTTPRequest $request, $fieldName, $configKey) {
        return $request->postVar($fieldName)
            ?: date('Y-m-d', strtotime(self::get_config_setting('date_field_config', $configKey)));
    }
}