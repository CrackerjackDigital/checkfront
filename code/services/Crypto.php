<?php

/**
 * Base class for Crypto implementations, provides some common functionality.
 */
abstract class CheckfrontCrypto extends Object
    implements CheckfrontCryptoInterface {

    const TokenItemIDIndex    = 0;
    const TokenStartDateIndex = 1;
    const TokenEndDateIndex   = 2;
    const TokenAccessKeyIndex = 3;

    const TokenDelimiter = '|'; // something not likely to be in data/time or other token fields.

    // the name used by config to lookup the server key (may be override by config.server_key_config_name).
    const ServerKeyConfigName = 'server_key';

    // by default we use whatever is in self.ServerKeyConfigName as the config variable name
    private static $server_key_config_name = self::ServerKeyConfigName;

    /**
     * Add server key to the config.
     * @see CheckfrontCryptoInterface
     * @return array
     */
    public static function get_extra_config() {
        $serverKeyConfigName = (string)static::config()->get('server_key_config_name');

        return array(
            $serverKeyConfigName => static::config()->get($serverKeyConfigName)
        );
    }

    /**
     * Return the native value from a 'friendly' value returned by the 'friendly' function.
     *
     * @param string $friendlyValue - value generated by the 'friendly' function.
     *
     * @return mixed - unfriendly value usefull directly to crypto libraries etc
     */
    abstract protected function unfriendly($friendlyValue);

    /**
     * Get the private server key which should be kept private from config.crypto_server_key
     * (really config.(config.crypto_server_key_name)). This should returned as the 'friendly' version of
     * a key generated by self.generate_key.
     * @see CheckfrontCryptoInterface
     * @return string - friendly
     */
    public function server_key() {
        return static::config()->get(
            (string)static::config()->get('server_key_config_name')
        );
    }


    /**
     * Returns encrypted plain text value first by server key then optionally using supplied key.
     *
     * @param $plainTextValue
     * @param $friendlyKeySecondPass - 'friendly' version of self.generate_key output
     *
     * @return string - maybe unfriendly
     * @throws Exception
     */
    public function encrypt($plainTextValue, $friendlyKeySecondPass = null) {
        $encrypted = $this->encrypt_native(
            $plainTextValue,
            $this->server_key()
        );
        if ($friendlyKeySecondPass) {
            // second pass
            $encrypted = $this->encrypt_native(
                $encrypted,
                $friendlyKeySecondPass
            );
        }

        return $encrypted;
    }


    /**
     * @param $encryptedValue
     * @param $friendlyKeySecondPass - 'friendly' version of self.generate_key output
     *
     * @return string - maybe unfriendly
     * @throws Exception
     */
    public function decrypt($encryptedValue, $friendlyKeySecondPass = null) {
        if ($friendlyKeySecondPass) {
            $encryptedValue = $this->decrypt_native(
                $encryptedValue,
                $friendlyKeySecondPass
            );
        }

        return $this->decrypt_native(
            $encryptedValue,
            $this->server_key()
        );
    }

    /**
     * @see CheckfrontCryptoInterface
     *
     * @param $itemID
     * @param $startDate
     * @param $endDate
     * @param null $accessKey
     *
     * @return string - friendly (tokens should always be friendly)
     * @throws Exception
     */
    public function encrypt_token($itemID, $startDate, $endDate, $accessKey = null) {
        try {
            // get these in the right order
            $values = array(
                static::TokenItemIDIndex    => $itemID,
                static::TokenStartDateIndex => $startDate,
                static::TokenEndDateIndex   => $endDate,
            );
            $token  = implode(
                $this->config()->get('token_delimiter'),
                array_values($values)
            );

            return $this->friendly($this->encrypt($token, $accessKey));

        } catch (Exception $e) {
            throw new Exception("Failed to " . __METHOD__);
        }
    }

    /**
     * @see CheckfrontCryptoInterface
     *
     * @param $friendlyToken
     * @param null|string $accessKey
     *
     * @return array
     * @throws Exception
     */
    public function decrypt_token($friendlyToken, $accessKey = null) {
        try {
            // these should come out in order they where encrypted
            $values = explode(
                $this->config()->get('token_delimiter'),
                $this->decrypt(
                    $this->unfriendly($friendlyToken),
                    $accessKey
                )
            );

            return $values;
        } catch (Exception $e) {
            throw new Exception("Failed to " . __METHOD__);
        }
    }

}