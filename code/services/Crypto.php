<?php

/**
 * Base class for Crypto implementations, provides some common functionality.
 */
abstract class CheckfrontCrypto extends Object implements CheckfrontCryptoInterface {
    const TokenItemIDIndex = 0;
    const TokenStartDateIndex = 1;
    const TokenEndDateIndex = 2;
    const TokenAccessKeyIndex = 3;

    const LinkPartDelimeter = '|';  // something not likely to be in data/time fields.

    /**
     * Return an encoded 'token' of passed parameters which can be passed on link into the system booking pages.
     * Dates will be converted to 'checkfront' dates so YYYYMMDD. The return token is hex2bin encoded ready to pass
     * on e.g. request.
     *
     * @param $accessKey - this should be generated by CheckfrontModule.make_access_key
     * @param $itemID
     * @param $startDate
     * @param $endDate
     *
     * @throws Exception
     * @return null|string - bin2hex encoded encrypted token
     */
    public static function encrypt_token($accessKey, $itemID, $startDate, $endDate) {
        try {
            // get these in the right order
            $values = array(
                static::TokenItemIDIndex => $itemID,
                static::TokenStartDateIndex => $startDate,
                static::TokenEndDateIndex => $endDate,
            );
            $value = implode(
                static::LinkPartDelimeter,
                array_values($values)
            );

            return static::friendly(
                static::encrypt(
                    static::encrypt(
                        $value,
                        static::server_key()
                    ),
                    $accessKey
                )
            );
        } catch (Exception $e) {
            throw new Exception("Failed to encrypt_token");
        }
    }

    /**
     * Return array of packageID, $startDate, $endDate from a provided encoded link segment. Start data and end date
     * will be 'checkfront' dates so YYYYMMDD. Returned array number and sequence matches the
     * parameters passed to self.encode_token call.
     *
     * @param $accessKey  - used when the link was encrypted, not encoded when passed.
     * @param $token      - link to decrypt into parts, will be hex2bin converted before passing to Crypto
     * @param null $index - optionally only return a single value from decoded array
     *
     * @throws Exception
     * @return null|array|string - [packageID, startDate, endDate]
     */
    public static function decrypt_token($accessKey, $token, $index = null) {
        try {
            // these should come out in order they where encrypted
            $values = explode(
                static::LinkPartDelimeter,
                static::decrypt(
                    static::decrypt(
                        static::unfriendly($token),
                        $accessKey
                    ),
                    static::server_key()
                )
            );
            if (!is_null($index)) {
                return $values[$index];
            }
            return $values;
        } catch (Exception $e) {
            throw new Exception("Failed to decrypt_token");
        }
    }

    /**
     * Return the private server key set in config.server_key of implementation
     * @return mixed
     */
    abstract public static function server_key();

    /**
     * Return a value which is safe to use in url's and copy-paste operations and is
     * ANSI. May not actually have anything to do with PHP url_encode etc such as using binToHex
     *
     * @param $rawValue
     *
     * @return mixed
     */
    abstract public static function friendly($rawValue);

    /**
     * Return the raw value for a cooked value which may be unsafe to use in urls, human-unfriendly etc
     * May not have anything to do with url_decode but us something like hexToBin
     *
     * @param $cookedValue
     *
     * @return mixed
     */
    abstract public static function unfriendly($cookedValue);

    /**
     * Encrypt value optionally using key
     *
     * @param $plainTextValue
     * @param $key
     *
     * @return mixed
     */
    abstract public static function encrypt($plainTextValue, $key = null);

    /**
     * Decrypt value optionally using key
     *
     * @param $encryptedValue
     * @param $key
     *
     * @return mixed
     */
    abstract public static function decrypt($encryptedValue, $key = null);

    /**
     * Generate a new access key. It may be ugly so needs to be e.g.
     * cooked() before being presented to the client for copy/paste etc and
     * so will also need to be decoded at the other end.
     *
     * @param null $salt
     *
     * @return string
     */
    abstract public static function generate_key($salt = null);
}