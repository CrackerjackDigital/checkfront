<?php
use \Defuse\Crypto\Crypto as Crypto;

class CheckfrontCryptoDefuse extends Object implements CheckfrontCryptoInterface {
    /** @var string set in config as bin2hex of key from Crypto.createNewRandomKey (link generator AcccessKey is one) */
    private static $server_key = '';

    /**
     * Returns unfriendly version of friendly config.server_key.
     */
    public static function server_key() {
        return self::unfriendly(static::config()->get('server_key'));
    }

    /**
     * Use Crypto.binToHex to make url-friendly, copy-paste friendly value.
     *
     * @param $rawValue
     *
     * @return mixed - binToHex'd value
     */
    public static function friendly($rawValue) {
        return Crypto::binToHex($rawValue);
    }

    /**
     * Uses Crypto.hexToBin to convert a self.urlencoded value back to raw value
     *
     * @param $cookedValue
     *
     * @return mixed - hexToBin'd value
     */
    public static function unfriendly($cookedValue) {
        return Crypto::hexToBin($cookedValue);
    }

    /**
     * @param $plainTextValue
     * @param $key - key generated by Crypto.createNewRandomKey, must be 'unfriendly'
     *
     * @return mixed|string
     * @throws Exception
     */
    public static function encrypt($plainTextValue, $key = null) {
        try {
            return Crypto::encrypt(
                $plainTextValue,
                $key
            );
        } catch (Exception $e) {
            throw new Exception("Failed to encrypt");
        }
    }

    /**
     * @param $encryptedValue
     * @param $key - key generated by Crypto.createNewRandomKey, must be 'unfriendly'
     *
     * @return \Defuse\Crypto\type|mixed
     * @throws Exception
     */
    public static function decrypt($encryptedValue, $key = null) {
        try {
            return Crypto::decrypt(
                $encryptedValue,
                $key
            );
        } catch (Exception $e) {
            throw new Exception("Failed to decrypt");
        }
    }

    /**
     * Generate an access key. It may be ugly so needs to be e.g.
     * base64_encoded or bin2hexed before being presented to the client for copy/paste etc and
     * so will also need to be decoded at the other end.
     *
     * @param null $unused - not used in this implementation
     *
     * @return string
     */
    public static function generate_key($unused = null) {
        $crypto = new Crypto();
        return $crypto->createNewRandomKey();
    }

}